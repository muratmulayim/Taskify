/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.ArrayDimension;
import org.xtext.example.mydsl.myDsl.ArrayReference;
import org.xtext.example.mydsl.myDsl.BooleanReference;
import org.xtext.example.mydsl.myDsl.BreakExpression;
import org.xtext.example.mydsl.myDsl.BuiltinFunctionCallExpression;
import org.xtext.example.mydsl.myDsl.DoubleReference;
import org.xtext.example.mydsl.myDsl.EntryTask;
import org.xtext.example.mydsl.myDsl.ForExpression;
import org.xtext.example.mydsl.myDsl.GlobalVariableExpression;
import org.xtext.example.mydsl.myDsl.IfExpression;
import org.xtext.example.mydsl.myDsl.InkApp;
import org.xtext.example.mydsl.myDsl.IntegerReference;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Operation;
import org.xtext.example.mydsl.myDsl.StatementBody;
import org.xtext.example.mydsl.myDsl.StringReference;
import org.xtext.example.mydsl.myDsl.Task;
import org.xtext.example.mydsl.myDsl.TaskBody;
import org.xtext.example.mydsl.myDsl.VariableDeclerationExpression;
import org.xtext.example.mydsl.myDsl.VariableReference;
import org.xtext.example.mydsl.myDsl.VariableType;
import org.xtext.example.mydsl.myDsl.WhileExpression;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ARRAY_DIMENSION:
				sequence_ArrayDimension(context, (ArrayDimension) semanticObject); 
				return; 
			case MyDslPackage.ARRAY_REFERENCE:
				sequence_Atomic(context, (ArrayReference) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN_REFERENCE:
				sequence_Atomic(context, (BooleanReference) semanticObject); 
				return; 
			case MyDslPackage.BREAK_EXPRESSION:
				sequence_BreakExpression(context, (BreakExpression) semanticObject); 
				return; 
			case MyDslPackage.BUILTIN_FUNCTION_CALL_EXPRESSION:
				sequence_BuiltinFunctionCallExpression(context, (BuiltinFunctionCallExpression) semanticObject); 
				return; 
			case MyDslPackage.DOUBLE_REFERENCE:
				sequence_Atomic(context, (DoubleReference) semanticObject); 
				return; 
			case MyDslPackage.ENTRY_TASK:
				sequence_EntryTask(context, (EntryTask) semanticObject); 
				return; 
			case MyDslPackage.FOR_EXPRESSION:
				sequence_ForExpression(context, (ForExpression) semanticObject); 
				return; 
			case MyDslPackage.GLOBAL_VARIABLE_EXPRESSION:
				sequence_GlobalVariableExpression(context, (GlobalVariableExpression) semanticObject); 
				return; 
			case MyDslPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case MyDslPackage.INK_APP:
				sequence_InkApp(context, (InkApp) semanticObject); 
				return; 
			case MyDslPackage.INTEGER_REFERENCE:
				sequence_Atomic(context, (IntegerReference) semanticObject); 
				return; 
			case MyDslPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case MyDslPackage.STATEMENT_BODY:
				sequence_StatementBody(context, (StatementBody) semanticObject); 
				return; 
			case MyDslPackage.STRING_REFERENCE:
				sequence_Atomic(context, (StringReference) semanticObject); 
				return; 
			case MyDslPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case MyDslPackage.TASK_BODY:
				sequence_TaskBody(context, (TaskBody) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_DECLERATION_EXPRESSION:
				sequence_VariableDeclerationExpression(context, (VariableDeclerationExpression) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_REFERENCE:
				sequence_Atomic(context, (VariableReference) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_TYPE:
				sequence_VariableType(context, (VariableType) semanticObject); 
				return; 
			case MyDslPackage.WHILE_EXPRESSION:
				sequence_WhileExpression(context, (WhileExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArrayDimension returns ArrayDimension
	 *
	 * Constraint:
	 *     (index=[VariableSymbol|ID] | size=INT)
	 */
	protected void sequence_ArrayDimension(ISerializationContext context, ArrayDimension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns ArrayReference
	 *     Atomic returns ArrayReference
	 *
	 * Constraint:
	 *     (variableReference=[VariableSymbol|ID] dimension+=ArrayDimension+)
	 */
	protected void sequence_Atomic(ISerializationContext context, ArrayReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns BooleanReference
	 *     Atomic returns BooleanReference
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_Atomic(ISerializationContext context, BooleanReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BOOLEAN_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BOOLEAN_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueBOOLEANTerminalRuleCall_3_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns DoubleReference
	 *     Atomic returns DoubleReference
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_Atomic(ISerializationContext context, DoubleReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DOUBLE_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DOUBLE_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueDOUBLETerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns IntegerReference
	 *     Atomic returns IntegerReference
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntegerReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INTEGER_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INTEGER_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns StringReference
	 *     Atomic returns StringReference
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRING_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRING_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns VariableReference
	 *     Atomic returns VariableReference
	 *
	 * Constraint:
	 *     variableReference=[VariableSymbol|ID]
	 */
	protected void sequence_Atomic(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_REFERENCE__VARIABLE_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_REFERENCE__VARIABLE_REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getVariableReferenceVariableSymbolIDTerminalRuleCall_5_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.VARIABLE_REFERENCE__VARIABLE_REFERENCE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BreakExpression returns BreakExpression
	 *     Expression returns BreakExpression
	 *
	 * Constraint:
	 *     break='break'
	 */
	protected void sequence_BreakExpression(ISerializationContext context, BreakExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BREAK_EXPRESSION__BREAK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BREAK_EXPRESSION__BREAK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBreakExpressionAccess().getBreakBreakKeyword_1_0(), semanticObject.getBreak());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BuiltinFunctionCallExpression returns BuiltinFunctionCallExpression
	 *     BlockExpressions returns BuiltinFunctionCallExpression
	 *     Expression returns BuiltinFunctionCallExpression
	 *
	 * Constraint:
	 *     (function=BuiltinFunctions (parameters+=Atomic parameters+=Atomic*)?)
	 */
	protected void sequence_BuiltinFunctionCallExpression(ISerializationContext context, BuiltinFunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntryTask returns EntryTask
	 *
	 * Constraint:
	 *     task=Task
	 */
	protected void sequence_EntryTask(ISerializationContext context, EntryTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENTRY_TASK__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENTRY_TASK__TASK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntryTaskAccess().getTaskTaskParserRuleCall_1_0(), semanticObject.getTask());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForExpression returns ForExpression
	 *     BlockExpressions returns ForExpression
	 *     Expression returns ForExpression
	 *
	 * Constraint:
	 *     (initial=OperationExpression test=OperationExpression update=OperationExpression body=StatementBody)
	 */
	protected void sequence_ForExpression(ISerializationContext context, ForExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR_EXPRESSION__INITIAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR_EXPRESSION__INITIAL));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR_EXPRESSION__TEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR_EXPRESSION__TEST));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR_EXPRESSION__UPDATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR_EXPRESSION__UPDATE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR_EXPRESSION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForExpressionAccess().getInitialOperationExpressionParserRuleCall_3_0(), semanticObject.getInitial());
		feeder.accept(grammarAccess.getForExpressionAccess().getTestOperationExpressionParserRuleCall_5_0(), semanticObject.getTest());
		feeder.accept(grammarAccess.getForExpressionAccess().getUpdateOperationExpressionParserRuleCall_7_0(), semanticObject.getUpdate());
		feeder.accept(grammarAccess.getForExpressionAccess().getBodyStatementBodyParserRuleCall_10_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVariableExpression returns GlobalVariableExpression
	 *     Expression returns GlobalVariableExpression
	 *
	 * Constraint:
	 *     variable=VariableDeclerationExpression
	 */
	protected void sequence_GlobalVariableExpression(ISerializationContext context, GlobalVariableExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GLOBAL_VARIABLE_EXPRESSION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GLOBAL_VARIABLE_EXPRESSION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalVariableExpressionAccess().getVariableVariableDeclerationExpressionParserRuleCall_2_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IfExpression returns IfExpression
	 *     BlockExpressions returns IfExpression
	 *     Expression returns IfExpression
	 *
	 * Constraint:
	 *     (ifcondition=OperationExpression ifbody=StatementBody (elseifcondition+=OperationExpression elseifbody+=StatementBody)* elsebody=StatementBody?)
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InkApp returns InkApp
	 *
	 * Constraint:
	 *     (globals+=GlobalVariableExpression* tasks+=Task* entry=EntryTask)
	 */
	protected void sequence_InkApp(ISerializationContext context, InkApp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockExpressions returns Operation
	 *     Expression returns Operation
	 *     OperationExpression returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (left=Operation_Operation_1_0 (operator+=Operator right+=Atomic)*)
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns StatementBody
	 *
	 * Constraint:
	 *     (body+=BlockExpressions* body+=BreakExpression?)
	 */
	protected void sequence_StatementBody(ISerializationContext context, StatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TaskBody returns TaskBody
	 *
	 * Constraint:
	 *     (body+=VariableDeclerationExpression* body+=BlockExpressions* (nexttask=[Task|ID] | endtask='end'))
	 */
	protected void sequence_TaskBody(ISerializationContext context, TaskBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (name=ID taskbody=TaskBody)
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TASK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TASK__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TASK__TASKBODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TASK__TASKBODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTaskAccess().getTaskbodyTaskBodyParserRuleCall_4_0(), semanticObject.getTaskbody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableDeclerationExpression
	 *     VariableDeclerationExpression returns VariableDeclerationExpression
	 *     VariableSymbol returns VariableDeclerationExpression
	 *
	 * Constraint:
	 *     (type=VariableType (name=ID | (name=ID dimension+=ArrayDimension+)))
	 */
	protected void sequence_VariableDeclerationExpression(ISerializationContext context, VariableDeclerationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableType returns VariableType
	 *
	 * Constraint:
	 *     (type='string' | type='integer' | type='boolean')
	 */
	protected void sequence_VariableType(ISerializationContext context, VariableType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhileExpression returns WhileExpression
	 *     BlockExpressions returns WhileExpression
	 *     Expression returns WhileExpression
	 *
	 * Constraint:
	 *     (test=OperationExpression body=StatementBody)
	 */
	protected void sequence_WhileExpression(ISerializationContext context, WhileExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.WHILE_EXPRESSION__TEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.WHILE_EXPRESSION__TEST));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.WHILE_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.WHILE_EXPRESSION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileExpressionAccess().getTestOperationExpressionParserRuleCall_3_0(), semanticObject.getTest());
		feeder.accept(grammarAccess.getWhileExpressionAccess().getBodyStatementBodyParserRuleCall_6_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
