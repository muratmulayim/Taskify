/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.ArrayDimension;
import org.xtext.example.mydsl.myDsl.ArrayReference;
import org.xtext.example.mydsl.myDsl.BooleanReference;
import org.xtext.example.mydsl.myDsl.Break;
import org.xtext.example.mydsl.myDsl.BuiltinFunctionCall;
import org.xtext.example.mydsl.myDsl.DoubleReference;
import org.xtext.example.mydsl.myDsl.EntryTask;
import org.xtext.example.mydsl.myDsl.ForExpression;
import org.xtext.example.mydsl.myDsl.FunctionBody;
import org.xtext.example.mydsl.myDsl.FunctionCall;
import org.xtext.example.mydsl.myDsl.FunctionDefinition;
import org.xtext.example.mydsl.myDsl.FunctionParameter;
import org.xtext.example.mydsl.myDsl.GlobalVariable;
import org.xtext.example.mydsl.myDsl.IfExpression;
import org.xtext.example.mydsl.myDsl.InkApp;
import org.xtext.example.mydsl.myDsl.IntegerReference;
import org.xtext.example.mydsl.myDsl.Main;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Operation;
import org.xtext.example.mydsl.myDsl.StringReference;
import org.xtext.example.mydsl.myDsl.Task;
import org.xtext.example.mydsl.myDsl.VariableDecleration;
import org.xtext.example.mydsl.myDsl.VariableReference;
import org.xtext.example.mydsl.myDsl.VariableReturn;
import org.xtext.example.mydsl.myDsl.VariableType;
import org.xtext.example.mydsl.myDsl.WhileExpression;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ARRAY_DIMENSION:
				sequence_ArrayDimension(context, (ArrayDimension) semanticObject); 
				return; 
			case MyDslPackage.ARRAY_REFERENCE:
				sequence_Atomic(context, (ArrayReference) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN_REFERENCE:
				sequence_Atomic(context, (BooleanReference) semanticObject); 
				return; 
			case MyDslPackage.BREAK:
				sequence_Break(context, (Break) semanticObject); 
				return; 
			case MyDslPackage.BUILTIN_FUNCTION_CALL:
				sequence_BuiltinFunctionCall(context, (BuiltinFunctionCall) semanticObject); 
				return; 
			case MyDslPackage.DOUBLE_REFERENCE:
				sequence_Atomic(context, (DoubleReference) semanticObject); 
				return; 
			case MyDslPackage.ENTRY_TASK:
				sequence_EntryTask(context, (EntryTask) semanticObject); 
				return; 
			case MyDslPackage.FOR_EXPRESSION:
				sequence_ForExpression(context, (ForExpression) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_BODY:
				sequence_FunctionBody(context, (FunctionBody) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_PARAMETER:
				sequence_FunctionParameter(context, (FunctionParameter) semanticObject); 
				return; 
			case MyDslPackage.GLOBAL_VARIABLE:
				sequence_GlobalVariable(context, (GlobalVariable) semanticObject); 
				return; 
			case MyDslPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case MyDslPackage.INK_APP:
				sequence_InkApp(context, (InkApp) semanticObject); 
				return; 
			case MyDslPackage.INTEGER_REFERENCE:
				sequence_Atomic(context, (IntegerReference) semanticObject); 
				return; 
			case MyDslPackage.MAIN:
				sequence_Main(context, (Main) semanticObject); 
				return; 
			case MyDslPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case MyDslPackage.STRING_REFERENCE:
				sequence_Atomic(context, (StringReference) semanticObject); 
				return; 
			case MyDslPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_DECLERATION:
				sequence_VariableDecleration(context, (VariableDecleration) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_REFERENCE:
				sequence_Atomic(context, (VariableReference) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_RETURN:
				sequence_VariableReturn(context, (VariableReturn) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_TYPE:
				sequence_VariableType(context, (VariableType) semanticObject); 
				return; 
			case MyDslPackage.WHILE_EXPRESSION:
				sequence_WhileExpression(context, (WhileExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArrayDimension returns ArrayDimension
	 *
	 * Constraint:
	 *     (index=[VariableSymbol|ID] | size=INT)
	 */
	protected void sequence_ArrayDimension(ISerializationContext context, ArrayDimension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns ArrayReference
	 *     Atomic returns ArrayReference
	 *     AtomicOrFunctionCall returns ArrayReference
	 *
	 * Constraint:
	 *     (variableReference=[VariableSymbol|ID] dimension+=ArrayDimension+)
	 */
	protected void sequence_Atomic(ISerializationContext context, ArrayReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns BooleanReference
	 *     Atomic returns BooleanReference
	 *     AtomicOrFunctionCall returns BooleanReference
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_Atomic(ISerializationContext context, BooleanReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BOOLEAN_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BOOLEAN_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueBOOLEANTerminalRuleCall_3_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns DoubleReference
	 *     Atomic returns DoubleReference
	 *     AtomicOrFunctionCall returns DoubleReference
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_Atomic(ISerializationContext context, DoubleReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DOUBLE_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DOUBLE_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueDOUBLETerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns IntegerReference
	 *     Atomic returns IntegerReference
	 *     AtomicOrFunctionCall returns IntegerReference
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntegerReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INTEGER_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INTEGER_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns StringReference
	 *     Atomic returns StringReference
	 *     AtomicOrFunctionCall returns StringReference
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRING_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRING_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation.Operation_1_0 returns VariableReference
	 *     Atomic returns VariableReference
	 *     AtomicOrFunctionCall returns VariableReference
	 *
	 * Constraint:
	 *     variableReference=[VariableSymbol|ID]
	 */
	protected void sequence_Atomic(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_REFERENCE__VARIABLE_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_REFERENCE__VARIABLE_REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getVariableReferenceVariableSymbolIDTerminalRuleCall_5_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.VARIABLE_REFERENCE__VARIABLE_REFERENCE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Break returns Break
	 *
	 * Constraint:
	 *     break='break'
	 */
	protected void sequence_Break(ISerializationContext context, Break semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BREAK__BREAK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BREAK__BREAK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBreakAccess().getBreakBreakKeyword_1_0(), semanticObject.getBreak());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BuiltinFunctionCall
	 *     AtomicOrFunctionCall returns BuiltinFunctionCall
	 *     BuiltinFunctionCall returns BuiltinFunctionCall
	 *     AbstractFunctionCall returns BuiltinFunctionCall
	 *
	 * Constraint:
	 *     (function=BuiltinFunctions (parameters+=Atomic parameters+=Atomic*)?)
	 */
	protected void sequence_BuiltinFunctionCall(ISerializationContext context, BuiltinFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntryTask returns EntryTask
	 *
	 * Constraint:
	 *     task=Task
	 */
	protected void sequence_EntryTask(ISerializationContext context, EntryTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENTRY_TASK__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENTRY_TASK__TASK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntryTaskAccess().getTaskTaskParserRuleCall_1_0(), semanticObject.getTask());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForExpression returns ForExpression
	 *     Expression returns ForExpression
	 *
	 * Constraint:
	 *     (initial=OperationExpression test=OperationExpression update=OperationExpression body+=Expression* body+=Break?)
	 */
	protected void sequence_ForExpression(ISerializationContext context, ForExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBody returns FunctionBody
	 *
	 * Constraint:
	 *     (variableDeclerations+=VariableDecleration* body+=Expression*)
	 */
	protected void sequence_FunctionBody(ISerializationContext context, FunctionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AtomicOrFunctionCall returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *     AbstractFunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (function=[FunctionDefinition|ID] (parameters+=Atomic parameters+=Atomic*)?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (return=VariableType name=ID (parameters+=FunctionParameter parameters+=FunctionParameter*)? body+=Expression*)
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionParameter returns FunctionParameter
	 *     VariableSymbol returns FunctionParameter
	 *
	 * Constraint:
	 *     (type=VariableType name=ID)
	 */
	protected void sequence_FunctionParameter(ISerializationContext context, FunctionParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_SYMBOL__TYPE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_SYMBOL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionParameterAccess().getTypeVariableTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFunctionParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVariable returns GlobalVariable
	 *
	 * Constraint:
	 *     variable=VariableDecleration
	 */
	protected void sequence_GlobalVariable(ISerializationContext context, GlobalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GLOBAL_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GLOBAL_VARIABLE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalVariableAccess().getVariableVariableDeclerationParserRuleCall_2_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IfExpression returns IfExpression
	 *     Expression returns IfExpression
	 *
	 * Constraint:
	 *     (
	 *         ifcondition=OperationExpression 
	 *         ifbody+=Expression* 
	 *         ifbody+=Break? 
	 *         (elsecondition+=OperationExpression elseifbody+=Expression* elseifbody+=Break?)* 
	 *         elsebody+=Expression* 
	 *         elseifbody+=Break?
	 *     )
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InkApp returns InkApp
	 *
	 * Constraint:
	 *     (globals+=GlobalVariable* tasks+=Task* entry=EntryTask)
	 */
	protected void sequence_InkApp(ISerializationContext context, InkApp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Main returns Main
	 *
	 * Constraint:
	 *     (variableDeclerations+=VariableDecleration* body+=Expression*)
	 */
	protected void sequence_Main(ISerializationContext context, Main semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Operation
	 *     OperationExpression returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (left=Operation_Operation_1_0 (operator+=Operator right+=AtomicOrFunctionCall)*)
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (name=ID body+=VariableDecleration* body+=Expression* task=[Task|ID]?)
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDecleration returns VariableDecleration
	 *     VariableSymbol returns VariableDecleration
	 *
	 * Constraint:
	 *     (type=VariableType (name=ID | (name=ID dimension+=ArrayDimension+)))
	 */
	protected void sequence_VariableDecleration(ISerializationContext context, VariableDecleration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableReturn returns VariableReturn
	 *
	 * Constraint:
	 *     return=Atomic
	 */
	protected void sequence_VariableReturn(ISerializationContext context, VariableReturn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_RETURN__RETURN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_RETURN__RETURN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableReturnAccess().getReturnAtomicParserRuleCall_1_0(), semanticObject.getReturn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableType returns VariableType
	 *
	 * Constraint:
	 *     {VariableType}
	 */
	protected void sequence_VariableType(ISerializationContext context, VariableType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhileExpression returns WhileExpression
	 *     Expression returns WhileExpression
	 *
	 * Constraint:
	 *     (test=OperationExpression body+=Expression* body+=Break?)
	 */
	protected void sequence_WhileExpression(ISerializationContext context, WhileExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
