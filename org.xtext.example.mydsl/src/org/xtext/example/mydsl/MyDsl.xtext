grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

InkApp:
	globals += GlobalVariableExpression*
	tasks+=Task*
	entry = EntryTask
;

LogicalOperator:
	'AND' | 'OR'
;

ComparisionOperator:
	 '>=' | '<=' | '==' | '!=' | '<' | '>'
;

AssignmentOperator:
	'='
;

ArithmeticOperator:
	'-' | '+' | '/' | '*'
;

Operator:
	ArithmeticOperator | 
	ComparisionOperator | 
	LogicalOperator | 
	AssignmentOperator
;

BuiltinFunctions:
	'print'
;

BreakExpression:
	{BreakExpression}
	break = 'break'
;

terminal DOUBLE returns ecore::EDouble:
	INT '.' INT
;
	
terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;

VariableType:
	{VariableType} 
	type = ('string' | 'integer' |  'boolean')
;

GlobalVariableExpression:
	{GlobalVariableExpression}
	'GLOBAL' variable = VariableDeclerationExpression
;

//ConstantVariableExpression:
//	{ConstantVariableExpression}
//	'CONSTANT' variable = VariableDeclerationExpression
//;

//Main:
//	{Main}
//	variableDeclerations += VariableDecleration*
//	body += Expression*
//;
//
//FunctionBody:
//	{FunctionBody}
//	variableDeclerations += VariableDecleration* 
//	body += Expression*
//;

EntryTask:
	'entry' task = Task
;

Task:
	{Task}
	'task' name = ID '{'
		taskbody = TaskBody
	'}'
;

IfExpression:
	{IfExpression}
	'if' '(' ifcondition = OperationExpression ')' '{'
		ifbody = StatementBody
	'}' 
	('else' 'if' '(' elseifcondition += OperationExpression ')' '{'
		elseifbody += StatementBody
	'}')*
	('else' '{'
		elsebody = StatementBody
	'}')?
;

ForExpression:
	{ForExpression}
	'for' '(' initial = OperationExpression ';' test = OperationExpression ';' update = OperationExpression ')' '{'
		body = StatementBody
	'}' 
;

WhileExpression:
	{WhileExpression}
	'while' '(' test = OperationExpression ')' '{'
		body = StatementBody
	'}' 
;

BuiltinFunctionCallExpression:
	{BuiltinFunctionCallExpression}
	function = BuiltinFunctions '(' (parameters += Atomic (',' parameters += Atomic)*)? ')'
;

//AbstractFunctionCall:
//	FunctionCall | 
//	BuiltinFunctionCallExpression
//;

TaskBody:
	{TaskBody}
	body += VariableDeclerationExpression*
	body += BlockExpressions*
	('next' nexttask = [Task] | endtask = 'end')
;

StatementBody:
	{StatementBody} 
	body += BlockExpressions*
	(body += BreakExpression)?
;

BlockExpressions:
	OperationExpression |
	IfExpression |
	ForExpression |
	WhileExpression |
	BuiltinFunctionCallExpression
;

Expression:
	BreakExpression |
	BuiltinFunctionCallExpression |
	OperationExpression |
	ForExpression |
	GlobalVariableExpression|
	IfExpression |
	VariableDeclerationExpression |
	WhileExpression
;

OperationExpression:
	Operation
;

Operation returns OperationExpression:
	Atomic ({Operation.left = current} (operator += Operator right += Atomic)*)
;

ArrayDimension:
	{ArrayDimension}
	'[' (index = [VariableSymbol] | size = INT) ']'
;

VariableDeclerationExpression:
	type = VariableType (name = ID | name = ID (dimension += ArrayDimension)+)
;

VariableSymbol:
	VariableDeclerationExpression
;

Atomic:
	{IntegerReference} value = INT |
	{DoubleReference} value = DOUBLE |
	{StringReference} value = STRING |
	{BooleanReference} value = BOOLEAN |
	{ArrayReference} variableReference = [VariableSymbol] (dimension += ArrayDimension)+ |
 	{VariableReference} variableReference = [VariableSymbol]
;

//VariableSymbol:
//	FunctionParameter |
//	VariableDeclerationExpression
//;

//VariableReturn:
//	'return' return = Atomic
//;

//AtomicOrFunctionCall:
//	Atomic | AbstractFunctionCall
//;

//FunctionParameter:
//	type = VariableType name = ID
//;

//FunctionDefinition:
//	'function' return=VariableType name=ID '(' (parameters += FunctionParameter (',' parameters += FunctionParameter)* )?   ')' '{'
//		body+=Expression*
//	'}'
//;

//FunctionCall:
//	{FunctionCall}
//	function=[FunctionDefinition] '(' (parameters += Atomic (',' parameters += Atomic)*)? ')'
//;


