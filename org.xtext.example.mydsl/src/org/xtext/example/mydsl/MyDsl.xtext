grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


InkApp:
	shareds += SharedVariableExpression*
	constants += ConstantVariableExpression*
	functions += FunctionDefinition*
	entry = EntryTask
	tasks+=Task*
;

terminal DOUBLE returns ecore::EDouble:
	INT '.' INT
;
	
terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;

LogicalOperator:
	'AND' | 'OR'
;

BitwiseOperator:
	"AND_BITWISE" | "OR_BITWISE" | "SHIFT_LEFT" | "SHIFT_RIGHT"
;

ComparisionOperator:
	 '>=' | '<=' | '==' | '!=' | '<' | '>'
;

AssignmentOperator:
	'='
;

ArithmeticOperator:
	'-' | '+' | '/' | '*'
;

Operator:
	ArithmeticOperator | 
	LogicalOperator |
	BitwiseOperator
;

BreakExpression:
	{BreakExpression}
	break = 'break'
;

VariableType:
	'string' | 'integer' |  'boolean'
;

ArrayDimension:
	{ArrayDimension}
	'[' (index = [VariableSymbol] | size = INT) ']'
;

VariableSymbol:
	FunctionDefinitionParameter |
	VariableDeclerationExpression | 
	ConstantVariableExpression |
	SharedVariableExpression
;

Variable:
	{ArrayReference} arrayReference = [VariableSymbol] (index = ArrayDimension) |
 	{VariableReference} variableReference = [VariableSymbol]
;

PrimitiveReference:
	{IntegerReference} value =  INT |
	{DoubleReference} value = DOUBLE |
	{StringReference} value = STRING |
	{BooleanReference} value = BOOLEAN
;

Atomic:
	PrimitiveReference | Variable
;


/********************* Function and function call Expressions ************************/
FunctionCallParameters:
	parameter += Atomic (',' parameter += Atomic)*
;

BuiltinPrintFunction:
	{BuiltinPrintFunction}
	'print' '(' parameters = FunctionCallParameters ')'
;

BuiltinRandomFunction:
	{BuiltinRandomFunction}
	'random' '(' ')'
;

BuiltinFunctionCallExpression:
	BuiltinPrintFunction |
	BuiltinRandomFunction
;

FunctionDefinitionParameter:
	{FunctionDefinitionParameter}
	type = VariableType name = ID
;

FunctionDefinitionParameters:
	{FunctionDefinitionParameters}
	typedVariableList += FunctionDefinitionParameter (',' typedVariableList += FunctionDefinitionParameter)*
;

FunctionDefinition:
	{FunctionDefinition}
	type = VariableType name = ID '(' parameters = FunctionDefinitionParameters ')' '{'
		body += VariableDeclerationExpression*
		body += BlockExpressions*
		'return' return = Atomic 
	'}'
;

CustomFunctionCallExpression:
	{CustomFunctionCallExpression}
	function = [FunctionDefinition] '(' parameters = FunctionCallParameters ')'
;

ArrayAssignment:
	'[' variable += Atomic (',' variable += Atomic)* ']'
;

ComparisionExpression:
	{ComparisionExpression}
	left = OperationExpression operator = ComparisionOperator right = OperationExpression
;


/********************* Operation expressions ************************/
OperationExpression:
	Operation
;

Operation returns Operation:
	left = PrimaryOperation ({Operation.left=current} operator += Operator right += PrimaryOperation)*
;

PrimaryOperation returns Operation:
	InParanthesisOperation | Atomic
;

InParanthesisOperation returns Operation:
	{InParanthesisOperation}
	'(' operation = Operation ')'
;


/********************* Assignment and Variable Declaration expressions ************************/
VariableAssignment:
	{VariableAssignment} 
	operator = AssignmentOperator expression = (OperationExpression | ArrayAssignment | BuiltinRandomFunction | CustomFunctionCallExpression)
;

VariableAssignmentExpression:
	{VariableAssignmentExpression}
	variable = Variable assignment = VariableAssignment
;

VariableDeclerationExpression:
	{VariableDeclerationExpression}
	type = VariableType name = ID (dimension = ArrayDimension)? (assignment = VariableAssignment)?
;

SharedVariableExpression:
	{SharedVariableExpression}
	'SHARED' type = VariableType name = ID (dimension = ArrayDimension)?
;

ConstantVariableExpression:
	{ConstantVariableExpression}
	'CONSTANT' type = VariableType name = ID (dimension = ArrayDimension)? assignment = VariableAssignment
;


/********************* Loop expressions ************************/
IfExpression:
	{IfExpression}
	'if' '(' ifcondition = ComparisionExpression ')' '{'
		ifbody = StatementBody
	'}' 
	('else' 'if' '(' elseifcondition += ComparisionExpression ')' '{'
		elseifbody += StatementBody
	'}')*
	('else' '{'
		elsebody = StatementBody
	'}')?
;

ForExpression:
	{ForExpression}
	'for' '(' initial_variable = Variable initial_value = VariableAssignment ';' test = ComparisionExpression ';' update_variable = Variable update_value = VariableAssignment ')' '{'
		body = LoopBody
	'}' 
;

WhileExpression:
	{WhileExpression}
	'while' '(' test = ComparisionExpression ')' '{'
		body = LoopBody
	'}' 
;


/********************* Task expressions ************************/
EntryTask:
	'entry' task = Task
;

Task:
	{Task}
	'task' name = ID '{'
		taskbody = TaskBody
	'}'
;

BlockExpressions:
	VariableAssignmentExpression |
	IfExpression |
	ForExpression |
	WhileExpression |
	BuiltinFunctionCallExpression
;


/********************* Body expressions ************************/
NextTaskExpression:
	('next' nexttask = [Task] | endtask = 'end')
;

TaskBody:
	{TaskBody}
	body += VariableDeclerationExpression*
	body += BlockExpressions*
	(body += NextTaskExpression)?
;

StatementBody:
	{StatementBody} 
	body += BlockExpressions*
	(body += BreakExpression)?
	(body += NextTaskExpression)?
;

LoopBody:
	{LoopBody}
	body += BlockExpressions*
;



Expression:
	BreakExpression |
	BuiltinFunctionCallExpression |
	ConstantVariableExpression |
	ForExpression |
	SharedVariableExpression|
	IfExpression |
	OperationExpression |
	VariableAssignmentExpression |
	VariableDeclerationExpression |
	WhileExpression |
	NextTaskExpression
;






